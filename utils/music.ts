import { NoteObj, NoteName, Accidental, Question, KeySignature, ClefType, GameMode, Difficulty } from '../types';

// Audio Context Singleton
let audioCtx: AudioContext | null = null;

const getAudioContext = () => {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
  }
  return audioCtx;
};

export const playTone = (frequency: number, type: 'sine' | 'triangle' = 'triangle', duration = 0.5) => {
  const ctx = getAudioContext();
  if (ctx.state === 'suspended') {
    ctx.resume();
  }

  const osc = ctx.createOscillator();
  const gainNode = ctx.createGain();

  osc.type = type;
  osc.frequency.value = frequency;

  gainNode.gain.setValueAtTime(0, ctx.currentTime);
  gainNode.gain.linearRampToValueAtTime(0.3, ctx.currentTime + 0.02);
  gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

  osc.connect(gainNode);
  gainNode.connect(ctx.destination);

  osc.start();
  osc.stop(ctx.currentTime + duration);
};

// Offsets relative to A4 (440Hz). 
// Includes enharmonic equivalents needed for frequency calculation.
const NOTE_OFFSETS: Record<string, number> = {
  'Cb': -10, 'C': -9, 'C#': -8, 'Db': -8,
  'D': -7, 'D#': -6, 'Eb': -6,
  'E': -5, 'E#': -4, 'Fb': -6,
  'F': -4, 'F#': -3, 'Gb': -3,
  'G': -2, 'G#': -1, 'Ab': -1,
  'A': 0, 'A#': 1, 'Bb': 1,
  'B': 2, 'B#': 3, 'Cb_upper': 2 // special case if needed, but handled by logic
};

export const getFrequency = (note: string, octave: number): number => {
  let baseOffset = NOTE_OFFSETS[note];
  if (baseOffset === undefined) {
      // Fallback for edge cases like B# or Cb if not explicitly mapped above
      // But we mapped the common enharmonics generated by standard keys
      if(note === 'B#') baseOffset = -9 + 12; // C (next octave) relative to A
      else if (note === 'Cb') baseOffset = 2 - 12; // B (prev octave)
      else baseOffset = 0;
  }
  
  const octaveOffset = (octave - 4) * 12;
  const semitonesFromA4 = baseOffset + octaveOffset;
  return 440 * Math.pow(2, semitonesFromA4 / 12);
};

// --- Music Theory Data ---

// Key Signatures mapping: Key Name -> List of notes in scale
const SCALES: Record<KeySignature, NoteName[]> = {
  // Major Keys
  'C':  ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
  
  // Sharps
  'G':  ['G', 'A', 'B', 'C', 'D', 'E', 'F'],
  'D':  ['D', 'E', 'F', 'G', 'A', 'B', 'C'],
  'A':  ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
  'E':  ['E', 'F', 'G', 'A', 'B', 'C', 'D'],
  'B':  ['B', 'C', 'D', 'E', 'F', 'G', 'A'],
  'F#': ['F', 'G', 'A', 'B', 'C', 'D', 'E'], // F#, G#, A#, B, C#, D#, E#
  'C#': ['C', 'D', 'E', 'F', 'G', 'A', 'B'], // All sharps

  // Flats
  'F':  ['F', 'G', 'A', 'B', 'C', 'D', 'E'],
  'Bb': ['B', 'C', 'D', 'E', 'F', 'G', 'A'],
  'Eb': ['E', 'F', 'G', 'A', 'B', 'C', 'D'],
  'Ab': ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
  'Db': ['D', 'E', 'F', 'G', 'A', 'B', 'C'],
  'Gb': ['G', 'A', 'B', 'C', 'D', 'E', 'F'],
  'Cb': ['C', 'D', 'E', 'F', 'G', 'A', 'B'] // All flats
};

const KEY_ACCIDENTALS: Record<KeySignature, Record<string, Accidental>> = {
  'C':  {},
  
  // Sharps
  'G':  { 'F': '#' },
  'D':  { 'F': '#', 'C': '#' },
  'A':  { 'F': '#', 'C': '#', 'G': '#' },
  'E':  { 'F': '#', 'C': '#', 'G': '#', 'D': '#' },
  'B':  { 'F': '#', 'C': '#', 'G': '#', 'D': '#', 'A': '#' },
  'F#': { 'F': '#', 'C': '#', 'G': '#', 'D': '#', 'A': '#', 'E': '#' },
  'C#': { 'F': '#', 'C': '#', 'G': '#', 'D': '#', 'A': '#', 'E': '#', 'B': '#' },

  // Flats
  'F':  { 'B': 'b' },
  'Bb': { 'B': 'b', 'E': 'b' },
  'Eb': { 'B': 'b', 'E': 'b', 'A': 'b' },
  'Ab': { 'B': 'b', 'E': 'b', 'A': 'b', 'D': 'b' },
  'Db': { 'B': 'b', 'E': 'b', 'A': 'b', 'D': 'b', 'G': 'b' },
  'Gb': { 'B': 'b', 'E': 'b', 'A': 'b', 'D': 'b', 'G': 'b', 'C': 'b' },
  'Cb': { 'B': 'b', 'E': 'b', 'A': 'b', 'D': 'b', 'G': 'b', 'C': 'b', 'F': 'b' },
};

// Maps theoretical notes to the physical piano keys (using Sharp notation for black keys)
// Piano keys are: C, C#, D, D#, E, F, F#, G, G#, A, A#, B
const getPhysicalPianoKey = (note: NoteName, accidental: Accidental, octave: number): string => {
  const full = `${note}${accidental}`;
  let pNote = full;
  let pOctave = octave;

  // Handle enharmonics
  switch (full) {
    case 'Cb': pNote = 'B'; pOctave = octave - 1; break;
    case 'B#': pNote = 'C'; pOctave = octave + 1; break;
    case 'E#': pNote = 'F'; break;
    case 'Fb': pNote = 'E'; break;
    case 'Db': pNote = 'C#'; break;
    case 'Eb': pNote = 'D#'; break;
    case 'Gb': pNote = 'F#'; break;
    case 'Ab': pNote = 'G#'; break;
    case 'Bb': pNote = 'A#'; break;
  }
  
  return `${pNote}${pOctave}`;
};

// Helper to create a NoteObj
const createNote = (name: NoteName, octave: number, keySig: KeySignature): NoteObj => {
  const accidental = KEY_ACCIDENTALS[keySig][name] || '';
  const fullNoteName = `${name}${accidental}`; // Theoretical Name
  
  const pianoKey = getPhysicalPianoKey(name, accidental, octave);

  return {
    name,
    octave,
    accidental,
    fullCode: `${fullNoteName}${octave}`, 
    vexKey: `${name}${accidental}${octave}`, // Vexflow format
    frequency: getFrequency(fullNoteName, octave),
    pianoKey: pianoKey
  };
};

export const generateQuestion = (
  mode: GameMode, 
  clef: ClefType, 
  keySig: KeySignature,
  difficulty: Difficulty
): Question => {
  // Determine valid range based on Clef and Difficulty
  let minOctave = 3;
  let maxOctave = 5;

  if (difficulty === 'hard') {
    // Hard Mode: Expanded Ranges
    if (clef === 'bass') {
      minOctave = 2;
      maxOctave = 3; 
    } else if (clef === 'treble') {
      minOctave = 4;
      maxOctave = 6;
    } else {
      minOctave = 2;
      maxOctave = 6;
    }
  } else {
    // Normal Mode
    if (clef === 'bass') {
      minOctave = 3; 
      maxOctave = 3; 
    } else if (clef === 'treble') {
      minOctave = 4;
      maxOctave = 5;
    }
  }

  const scaleNotes = SCALES[keySig];
  
  // Pick a root note
  let rootName = scaleNotes[Math.floor(Math.random() * scaleNotes.length)];
  let rootOctave = Math.floor(Math.random() * (maxOctave - minOctave + 1)) + minOctave;

  // Boundary check
  if (rootOctave < 2) rootOctave = 2;
  if (rootOctave > 6) rootOctave = 6;

  const rootNote = createNote(rootName, rootOctave, keySig);
  const notes: NoteObj[] = [rootNote];

  if (mode === 'chord') {
    // Generate a triad (Root, 3rd, 5th)
    const rootIndex = scaleNotes.indexOf(rootName);
    
    // 3rd
    const thirdName = scaleNotes[(rootIndex + 2) % 7];
    const thirdOctave = (scaleNotes.indexOf(thirdName) < rootIndex) ? rootOctave + 1 : rootOctave;
    
    // 5th
    const fifthName = scaleNotes[(rootIndex + 4) % 7];
    const fifthOctave = (scaleNotes.indexOf(fifthName) < rootIndex) ? rootOctave + 1 : rootOctave;

    // Only add notes if they are within physical range
    if (thirdOctave <= 6) notes.push(createNote(thirdName, thirdOctave, keySig));
    if (fifthOctave <= 6) notes.push(createNote(fifthName, fifthOctave, keySig));
  }

  return {
    notes,
    rootFullCode: rootNote.fullCode
  };
};

export const checkAnswerSingle = (target: Question, clickedPianoKey: string): boolean => {
  // Compare the physical key pressed (e.g. "F4") with the theoretical note's physical mapping (e.g. "E#4" -> "F4")
  return target.notes[0].pianoKey === clickedPianoKey;
};